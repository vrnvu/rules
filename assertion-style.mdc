---
description: Assertion Style Rules
globs:
alwaysApply: true
---

# Assertion Style Rules

## Core Principles

### Two-Party Contracts
- Assert the same conditions at call site and definition site
- Both parties verify the same invariants
- Creates airlocks between code boundaries

**Airlocks**: Assertions create "airlocks" - safe boundaries between code sections. Between two assertions, an invariant is guaranteed to hold, so we're confident about the code properties. Like an airlock on a spaceship, it creates a controlled transition zone.

### Multiple Code Paths
- Multiple callers can reach the same function
- Assertions in function don't know which code path was taken
- Call site assertions verify the specific path taken

**Multiple Callers Problem**: If multiple code paths can reach the same function, when we add assertions to the function we don't know what code path we took to reach that function! That's why we need "two to contract" - we can have multiple callers, eachewith different assumptions about the state.

## Assertion Patterns

### Paired Assertions
- Assert preconditions at function entry
- Assert postconditions at function exit
- Assert the same conditions at call site and definition site

```python
# Call site
result = process_data(input_data)
assert result is not None
assert len(result) <= len(input_data)

# Definition site  
def process_data(data: list) -> list:
    assert data is not None
    # ... processing logic ...
    assert len(result) <= len(data)
    return result
```

### Implication Assertions
- Use if statements for implications: `if (condition) assert(consequence)`
- One line per implication
- Avoid logical operators for implications

```python
# Good: Clear implication
if user.is_authenticated:
    assert user.session_id is not None

# Bad: Hard to read logical form
assert not user.is_authenticated or user.session_id is not None
```

## Implementation Guidelines

### Preconditions and Postconditions
- Assert what the function requires at the beginning
- Assert what the function guarantees at the end
- Assert invariants throughout execution

```python
def binary_search(haystack: list[int], needle: int) -> bool:
    # Preconditions
    assert haystack is not None
    assert all(haystack[i] <= haystack[i+1] for i in range(len(haystack)-1))
    
    # ... search logic ...
    
    # Postconditions
    assert result in [True, False]
    if result:
        assert needle in haystack
    else:
        assert needle not in haystack
    
    return result
```

### State Validation
- Assert invariants at critical points
- Validate state transitions explicitly
- Use assertions to document expected state relationships

```python
class Database:
    def __init__(self):
        self._connected = False
        self._transaction_active = False
    
    def connect(self) -> None:
        assert not self._connected, "Already connected"
        # ... connection logic ...
        self._connected = True
        assert self._connected
    
    def begin_transaction(self) -> None:
        assert self._connected, "Must be connected to begin transaction"
        assert not self._transaction_active, "Transaction already active"
        # ... transaction logic ...
        self._transaction_active = True
```

### Error Detection
- Use assertions to catch programmer errors early
- Assertions should fail fast with clear messages
- Don't use assertions for expected runtime conditions

## Best Practices

### Assertion Placement
- Place assertions at function boundaries
- Assert invariants at loop beginnings
- Validate state after complex operations
- Use assertions to document assumptions

### Readability
- Write assertions that read like documentation
- Use descriptive variable names
- Group related assertions
- Make assertions self-documenting

### Performance
- Assertions should be fast to evaluate
- Avoid expensive computations in assertions
- Consider disabling in production if needed

## Anti-Patterns

- Asserting obvious conditions
- Asserting implementation details
- Using assertions for control flow
- Skipping assertions at function boundaries
- Assuming callers will validate inputs
- Generic assertion messages
- Assertions without explanatory messages